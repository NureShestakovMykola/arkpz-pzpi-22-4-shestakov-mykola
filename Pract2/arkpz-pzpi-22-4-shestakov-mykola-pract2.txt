Харківський університет радіоелектроніки 
Факультет комп'ютерних наук 
Кафедра програмної інженерії 




ЗВІТ
 до практичної роботи номер 2 з дисципліни
 "Аналіз та рефакторинг коду"
 на тему: " Методи рефакторингу коду програмного забезпечення" 













Виконав ст. гр ПЗПІ-22-4
Шестаков Микола Саркісович 


Перевірив 
ст. викладач кафедри ПІ 
Сокорчук Ігор Петрович 







Харків 2024

1 МЕТА

     Метою цієї практичної роботи є навчитися ідентифікувати проблеми у вихідному коді та застосовувати відповідні методи рефакторингу для їх усунення. Завдання спрямоване на підвищення якості коду, його читабельності та зручності підтримки, використовуючи реальні приклади з власних програмних проєктів.
     
2 ВСТУП

	У сучасній розробці програмного забезпечення якість коду є одним із ключових чинників, що визначає успішність проєкту. Рефакторинг коду – це процес вдосконалення внутрішньої структури програмного забезпечення без зміни його зовнішньої поведінки. Він дозволяє знизити технічний борг, підвищити читабельність коду та забезпечити його відповідність сучасним стандартам програмування. Основна мета рефакторингу полягає в тому, щоб зробити код більш простим у підтримці, адаптивним до змін і менш схильним до помилок, водночас зберігаючи його функціональність незмінною. Це є критично важливим у великих проєктах, де підтримка та розвиток коду займають значну частину часу. Крім того, правильно організований код сприяє підвищенню ефективності роботи команди та зниженню витрат на виправлення помилок.
     Необхідність рефакторингу виникає в кількох ситуаціях: коли складний або застарілий код перешкоджає впровадженню нових функціональних можливостей, коли потрібно виправити баги, але їх діагностика ускладнена, або ж коли існуючий технічний борг стає бар’єром для ефективного розвитку системи. Рефакторинг також є невід’ємною частиною сучасної розробки, особливо в умовах швидких змін вимог або під час роботи над довготривалими проєктами, де важливо підтримувати стабільність і якість коду в довгостроковій перспективі.
     Для виконання практичної роботи були обрані три методи рефакторингу з підручника Мартіна Фаулера Refactoring. Improving the Design of Existing Code. Ці методи дозволяють вирішити типові проблеми коду і водночас демонструють ефективність системного підходу до його вдосконалення:
1. Decompose Conditional: метод, який дозволяє розбити складні умовні конструкції на менші, зрозумілі компоненти, що значно підвищує читабельність і спрощує тестування.
2. Separate Query from Modifier: метод, який чітко розділяє запити даних (отримання інформації) і модифікацію стану (зміна даних), що знижує ризик побічних ефектів і покращує передбачуваність роботи коду.
3. Encapsulate Collection: метод, що запобігає неконтрольованому доступу до колекцій даних через створення чітких інтерфейсів для роботи з ними, забезпечуючи цілісність і безпеку змін.

3 ХІД РОБОТИ
  
МЕТОДИ РЕФАКТОРИНГУ КОДУ


	1. Перший метод Decompose Conditional (Розкладання умов)
     Проблематика: складні умовні конструкції, які включають вкладені блоки if-else або оператори switch, створюють суттєві труднощі у читанні та підтримці коду. Основною проблемою є зниження читабельності: розробникам складно швидко зрозуміти реалізовану в умовах логіку. Крім того, такі конструкції підвищують ризик помилок, оскільки зміна логіки в одній частині може призвести до неочікуваних наслідків у інших частинах програми через їх взаємозалежність. Наявність великої кількості умов значно ускладнює тестування, зокрема створення окремих тестів для кожного сценарію. Також часто спостерігається дублювання логіки, коли одна і та сама перевірка реалізується в різних частинах програми, що збільшує ймовірність несинхронності змін. Усі зазначені фактори перетворюють складні умовні конструкції на джерело технічного боргу, що негативно впливає на ефективність підтримки та розвиток програмного забезпечення. Рішенням є застосування методу Decompose Conditional або Розкладання умов
	Опис: Decompose Conditional (Розкладання умов) – це метод рефакторингу, що передбачає спрощення складних умовних конструкцій шляхом винесення окремих умов у самостійні функції чи методи з чітко визначеною назвою. Цей підхід спрямований на покращення читабельності та зрозумілості коду, а також на спрощення процесу внесення змін чи розширення функціональності. Метод використовується в ситуаціях, коли умовні конструкції містять занадто багато логіки, що ускладнює їхнє розуміння.
	Кроки рефакторингу:
1. Визначте складну умовну конструкцію, в якій використовуються блоки if-else або switch із великою кількістю перевірок чи вкладень.
2. Виділіть логічно окремі умови, проаналізувавши кожну перевірку та визначивши її роль у загальній логіці програми.
3. Створіть функції для кожної умови з інформативними назвами, які описують суть перевірки, і перенесіть відповідну логіку з умовної конструкції до функції.
4. Замініть умовні вирази в коді викликами новостворених функцій, зберігаючи логіку програми.
5. Перевірте коректність роботи програми після кожного внесення змін за допомогою тестування, щоб переконатися у збереженні початкової поведінки.
6. Оптимізуйте створені функції, перевіряючи їх на дублювання логіки, та видаліть зайві перевірки чи непотрібні елементи.
7. Проведіть фінальне тестування програми, щоб упевнитись у коректності функціоналу, зменшенні складності коду та його відповідності вимогам.
Приклад:
До рефакторингу:
function processOrder(order) {
  let discount = 0;

  if (order.customerType === "VIP" && order.totalAmount > 1000 && isHolidaySeason()) {
    discount = order.totalAmount * 0.2;
  } else if (order.customerType === "Regular" && order.totalAmount > 500 && order.isFirstOrder) {
    discount = order.totalAmount * 0.1;
  } else if (order.customerType === "New" && order.totalAmount > 300) {
    discount = order.totalAmount * 0.05;
  }

  if (order.paymentMethod === "CreditCard" && order.totalAmount > 2000) {
    discount += 50;
  } else if (order.paymentMethod === "BankTransfer" && order.totalAmount > 1500) {
    discount += 30;
  }

  if (order.totalAmount - discount < 0) {
    return { error: "Discount exceeds total amount" };
  }

  return {
    finalAmount: order.totalAmount - discount,
    appliedDiscount: discount,
  };
}

function isHolidaySeason() {
  const today = new Date();
  return today.getMonth() === 11; 
}

Після рефакторингу:
function processOrder(order) {
  const discount = calculateDiscount(order);
  const bonusDiscount = calculateBonusDiscount(order);

  const totalDiscount = discount + bonusDiscount;

  if (order.totalAmount - totalDiscount < 0) {
    return { error: "Discount exceeds total amount" };
  }

  return {
    finalAmount: order.totalAmount - totalDiscount,
    appliedDiscount: totalDiscount,
  };
}

function calculateDiscount(order) {
  if (isVipEligibleForDiscount(order)) {
    return order.totalAmount * 0.2;
  } else if (isRegularEligibleForDiscount(order)) {
    return order.totalAmount * 0.1;
  } else if (isNewCustomerEligibleForDiscount(order)) {
    return order.totalAmount * 0.05;
  }
  return 0;
}

function calculateBonusDiscount(order) {
  if (isCreditCardBonusApplicable(order)) {
    return 50;
  } else if (isBankTransferBonusApplicable(order)) {
    return 30;
  }
  return 0;
}

function isVipEligibleForDiscount(order) {
  return order.customerType === "VIP" && order.totalAmount > 1000 && isHolidaySeason();
}

function isRegularEligibleForDiscount(order) {
  return order.customerType === "Regular" && order.totalAmount > 500 && order.isFirstOrder;
}

function isNewCustomerEligibleForDiscount(order) {
  return order.customerType === "New" && order.totalAmount > 300;
}

function isCreditCardBonusApplicable(order) {
  return order.paymentMethod === "CreditCard" && order.totalAmount > 2000;
}

function isBankTransferBonusApplicable(order) {
  return order.paymentMethod === "BankTransfer" && order.totalAmount > 1500;
}

function isHolidaySeason() {
  const today = new Date();
  return today.getMonth() === 11; // December
}

     До рефакторингу функція processOrder містила громіздку умовну логіку, яка включала вкладені перевірки та повторювані умови. Це значно ускладнювало розуміння та підтримку коду. Різні аспекти логіки, такі як розрахунок знижки для клієнтів, бонусів за спосіб оплати та перевірка загальної суми, були зібрані разом, що робило функцію великою і важко читаною. Крім того, така структура ускладнювала тестування, оскільки вся логіка була взаємозалежною.
     Після рефакторингу умовну логіку було розбито на окремі спеціалізовані функції, кожна з яких відповідає за конкретний аспект. Наприклад, перевірки для різних категорій клієнтів (isVipEligibleForDiscount, isRegularEligible ForDiscount, isNewCustomerEligibleForDiscount) і способів оплати (isCredit CardBonusApplicable, isBankTransferBonusApplicable) було винесено в окремі функції з чіткими назвами. Це дозволило значно спростити основну функцію processOrder, яка тепер виконує лише обчислення на основі результатів 
     Переваги:
1. Покращення читабельності: код стає зрозумілішим завдяки виділенню кожної перевірки в окрему функцію з інформативною назвою. 
2. Полегшення тестування: ізоляція умов у вигляді окремих функцій спрощує їх перевірку. 
3. Зменшення складності: головна функція очищається від зайвої логіки, що полегшує її розуміння та підтримку.
4. Гнучкість і модульність: додавання або змінення умов стає простішим, оскільки кожна функція працює незалежно від інших.
5. Узгодженість логіки: функції із зрозумілими назвами документують логіку програми, роблячи її більш прозорою для команди.
6. Підвищення продуктивності розробників: Чистий і структурований код дозволяє зосередитися на створенні нових функціональних можливостей, а не на виправленні помилок чи вивченні складної логіки.
	2. Другий метод Separate Query from Modifier (Розділення запиту і модифікатора)
     Проблематика: методи, які одночасно виконують запити та модифікацію, створюють труднощі в роботі з кодом. Поєднання цих задач ускладнює розуміння призначення методу, збільшує ризик непередбачуваних побічних ефектів і ускладнює тестування. Наприклад, виклик методу може мати небажані наслідки, як-от зміну стану об’єкта, навіть якщо очікувалося лише отримання результату. Крім того, подібний код менш гнучкий для розширення або внесення змін, оскільки будь-яка зміна може вплинути на обидві функціональності одночасно. Ріщенням є застосування методу Separate Query from Modifier або Розділення запиту і модифікатора.
	Опис: Separate Query from Modifier (Розділення запиту і модифікатора) – це метод рефакторингу, який спрямований на чітке розмежування операцій отримання даних (запиту) та зміни стану об’єкта (модифікації). Його суть полягає у створенні окремих методів для виконання кожної з цих задач. Цей підхід дозволяє уникнути побічних ефектів, покращити передбачуваність коду та забезпечити його зрозумілість. Метод особливо корисний у ситуаціях, коли функції або методи поєднують дві ролі: вони змінюють дані та одночасно повертають результат.
	Кроки рефакторингу:
1. Визначте методи, які поєднують запит і модифікацію.
2. Створіть окремі методи для кожної задачі: один для отримання даних, другий – для змін стану об’єкта.
3. Перенесіть відповідну логіку з початкового методу до нових функцій.
4. Замініть виклики початкового методу у коді викликами новостворених функцій.
5. Перевірте коректність роботи програми після внесення змін за допомогою тестування.
6. Оптимізуйте код, видаляючи зайві перевірки або дублювання логіки.
7. Проведіть фінальне тестування, щоб переконатися у правильності реалізації та збереженні функціональності програми.
Приклад:
До рефакторингу: 

class ShoppingCart {
  constructor() {
    this.items = [];
  }

  getTotalAndClear() {
    let total = 0;
    for (let item of this.items) {
      total += item.price * item.quantity;
    }
    this.items = [];
    return total;
  }

  addItem(item) {
    this.items.push(item);
  }
}

const cart = new ShoppingCart();
cart.addItem({ name: "Book", price: 20, quantity: 2 });
cart.addItem({ name: "Pen", price: 2, quantity: 5 });

const total = cart.getTotalAndClear();
console.log(`Total: $${total}`);
console.log(`Cart items: ${cart.items.length}`);


Після рефакторингу:
class ShoppingCart {
  constructor() {
    this.items = [];
  }

  getTotal() {
    let total = 0;
    for (let item of this.items) {
      total += item.price * item.quantity;
    }
    return total;
  }

  clearCart() {
    this.items = [];
  }

  addItem(item) {
    this.items.push(item);
  }
}

const cart = new ShoppingCart();
cart.addItem({ name: "Book", price: 20, quantity: 2 });
cart.addItem({ name: "Pen", price: 2, quantity: 5 });

const total = cart.getTotal();
cart.clearCart();

console.log(`Total: $${total}`);
console.log(`Cart items: ${cart.items.length}`); 

     До рефакторингу метод getTotalAndClear поєднував дві різні задачі: обчислення загальної вартості товарів у кошику та його очищення. Такий підхід ускладнював розуміння коду, оскільки метод мав подвійне призначення. Крім того, він створював ризики несподіваних побічних ефектів — наприклад, дані про товари могли бути втрачені після виклику методу, навіть якщо очікувалося лише отримання загальної вартості. Це також ускладнювало тестування, адже перевірити кожну задачу окремо було неможливо через їхню взаємозалежність.
     Після рефакторингу задачі були розділені на два методи: getTotal, який відповідає лише за розрахунок загальної вартості, та clearCart, що виконує очищення кошика. Такий підхід дозволив реалізувати принцип єдиної відповідальності, зробивши кожен метод зрозумілим і простим у використанні. Код став передбачуваним, оскільки тепер розробник може точно контролювати, коли відбувається обчислення, а коли — очищення даних.
	Переваги: 
1. Передбачуваність і зниження ризику помилок: методи виконують одну задачу, що усуває побічні ефекти та мінімізує вплив змін в одній функції на інші частини програми.
2. Покращення читабельності: розділення функцій робить код більш зрозумілим і легким для підтримки, що полегшує його використання навіть новими членами команди.
3. Полегшення тестування: ізольованість кожного методу дозволяє тестувати їх незалежно, що спрощує виявлення та виправлення помилок.
4. Відповідність принципу єдиної відповідальності: чітке розмежування запитів і модифікацій підвищує структурованість і логічність коду, що сприяє масштабуванню.
5. Гнучкість: код стає простішим для розширення та модифікації, оскільки окремі задачі реалізуються незалежно одна від одної.
     3. Третій метод Encapsulate Collection (Інкапсуляція колекції)
     Проблематика: прямий доступ до колекцій, таких як масиви або списки, може створювати суттєві ризики. Наприклад, зовнішній код може ненавмисно змінити, видалити або порушити структуру даних, що може призвести до некоректної роботи програми. Відсутність контролю за змінами колекції ускладнює підтримку і тестування коду, особливо у великих проєктах. Крім того, внесення змін до структури колекції потребує оновлення всіх місць, де вона використовується напряму, що підвищує технічний борг. Рішенням є застосування методу Encapsulate Collection або Інкапсуляція колекції
	Опис: Encapsulate Collection (Інкапсуляція колекції) – це метод рефакторингу, який дозволяє захистити колекцію даних від прямого доступу та неконтрольованих змін. Його суть полягає у приховуванні деталей реалізації колекції за допомогою приватних полів та наданні контрольованого інтерфейсу для взаємодії з нею. Цей підхід забезпечує безпеку змін, підвищує модульність і дозволяє легко змінювати внутрішню структуру колекції без впливу на зовнішній код.
	Кроки рефакторингу:
1. Зробіть колекцію приватною, щоб виключити прямий доступ до неї.
2. Створіть методи для взаємодії з колекцією, наприклад, для додавання, видалення та отримання елементів.
3. Перевірте, чи потрібна додаткова логіка, наприклад, валідація даних, і додайте її до відповідних методів.
4. Замініть у коді всі прямі звернення до колекції на виклики нових методів.
5. Перевірте коректність роботи програми після внесення змін.
6. Проведіть оптимізацію методів, якщо виявлено дублювання або зайві перевірки.
7. Проведіть фінальне тестування, щоб упевнитись у правильності роботи програми та захищеності колекції.
Приклад:
До рефакторингу:
class Project {
  constructor() {
    this.tasks = [];
  }

  addTask(task) {
    this.tasks.push(task);
  }

  getTasks() {
    return this.tasks;
  }

  completeTask(taskId) {
    const task = this.tasks.find(task => task.id === taskId);
    if (task) {
      task.completed = true;
    }
  }

  clearCompletedTasks() {
    this.tasks = this.tasks.filter(task => !task.completed);
  }
}

const project = new Project();
project.addTask({ id: 1, name: "Design UI", completed: false });
project.addTask({ id: 2, name: "Write Documentation", completed: false });
project.addTask({ id: 3, name: "Implement Backend", completed: true });

project.completeTask(2);

console.log("Tasks before clearing completed:");
console.log(project.tasks);

project.clearCompletedTasks();

console.log("Tasks after clearing completed:");
console.log(project.tasks);

Після рефакторингу:
class Project {
  constructor() {
    this._tasks = [];
  }

  addTask(task) {
    if (!task.id || !task.name) {
      throw new Error("Invalid task data");
    }
    this._tasks.push({ ...task, completed: task.completed || false });
  }

  getTasks() {
    return [...this._tasks];
  }

  completeTask(taskId) {
    const index = this._tasks.findIndex(task => task.id === taskId);
    if (index !== -1) {
      this._tasks[index].completed = true;
    }
  }

  removeTask(taskId) {
    const index = this._tasks.findIndex(task => task.id === taskId);
    if (index !== -1) {
      this._tasks.splice(index, 1);
    }
  }

  clearCompletedTasks() {
    this._tasks = this._tasks.filter(task => !task.completed);
  }
}

const project = new Project();
project.addTask({ id: 1, name: "Design UI" });
project.addTask({ id: 2, name: "Write Documentation" });
project.addTask({ id: 3, name: "Implement Backend", completed: true });

project.completeTask(2);

console.log("Tasks before clearing completed:");
console.log(project.getTasks());

project.clearCompletedTasks();

console.log("Tasks after clearing completed:");
console.log(project.getTasks());

     До рефакторингу колекція tasks у класі Project була доступна напряму, що дозволяло зовнішньому коду змінювати її без контролю. Це створювало ризики некоректних змін, ускладнювало тестування та підтримку. Методи працювали з відкритим масивом, і будь-які модифікації могли залишитися непоміченими, що призводило до потенційних помилок.
     Після рефакторингу колекцію зроблено приватною (_tasks), а взаємодія з нею тепер здійснюється через чітко визначені методи, такі як addTask, completeTask і clearCompletedTasks. Це дозволило додати валідацію, захистити дані від некоректних змін і гарантувати централізований контроль над операціями. Метод getTasks повертає копію масиву, виключаючи можливість його прямої модифікації.
Переваги:
1. Контрольовані зміни: Прямий доступ до колекції виключено, що дозволяє забезпечити централізований контроль за всіма операціями через спеціалізовані методи.
2. Захист даних: Колекція стає захищеною від випадкових або некоректних змін з боку зовнішнього коду, що підвищує її надійність.
3. Полегшення підтримки: Всі зміни у структурі колекції ізольовані в одному класі, тому зовнішній код не потребує оновлення під час внесення змін до внутрішньої логіки.
4. Підвищення читабельності: Замість прямого доступу до колекції використовуються методи з чіткими назвами, які відображають логіку взаємодії з даними.
5. Гнучкість: Легко додавати нові операції або змінювати існуючі, не порушуючи зовнішню поведінку програми.
6. Покращення тестування: Централізований контроль за операціями з колекцією дозволяє легко створювати тести для кожного методу, що знижує ризик помилок.
7. Модульність і масштабованість: Код стає більш структурованим, і кожна операція із колекцією виконується незалежно, що сприяє простоті масштабування та внесення змін.

ІНСТРУМЕНТИ РЕФАКТОРИНГУ


	1. IDE з інтегрованими засобами рефакторингу.
     Багато сучасних IDE мають вбудовані функції для автоматизації рефакторингу коду, що спрощує виконання складних завдань і знижує ризики помилок. Нижче наведено огляд можливостей трьох найпопулярніших IDE: Eclipse, Visual Studio та IntelliJ IDEA.
     Eclipse (Java, C++, Python, PHP тощо) забезпечує користувачів зручними інструментами для рефакторингу з акцентом на Java. Основні функції включають:
1. Rename – перейменування змінних, методів, класів із автоматичною корекцією посилань.
2. Extract Method/Variable/Constant – виділення коду в новий метод, змінну або константу.
3. Encapsulate Field – створення геттерів і сеттерів для полів класу.
4. Change Method Signature – зміна параметрів методів із мінімальним впливом на інші частини проєкту.
5. Move – переміщення файлів і елементів коду між модулями.
     Visual Studio (C#, C++, VB.NET, JavaScript та інші) пропонує розширений набір інструментів для рефакторингу, особливо для проєктів на основі .NET. Основні функції включають:
1. Rename – безпечне перейменування змінних, методів, класів тощо.
2. Extract Method/Variable – виділення частини коду в новий метод або змінну для покращення читабельності.
3. Encapsulate Field – автоматичне перетворення поля на властивість із геттерами та сеттерами.
4. Remove Unused References – видалення невикористаних залежностей для спрощення проєкту.
5. Change Method Signature – зміна параметрів і типів методу.
     IntelliJ IDEA (Java, Kotlin, Python, JavaScript, PHP та інші) відома своєю потужною системою рефакторингу, яка охоплює всі аспекти роботи з кодом. Серед найпопулярніших функцій:
1. Rename – перейменування змінних, методів, класів без ризику пропустити посилання.
2. Extract Method/Variable – створення нових методів або змінних із виділеного блоку коду.
3. Inline Method/Variable – заміна методу або змінної безпосереднім значенням чи логікою.
4. Safe Delete – безпечне видалення методів, змінних і класів із перевіркою впливу на проєкт.
5. Move – переміщення класів, методів або файлів у нові модулі чи пакети.
6. Refactor This – швидкий доступ до всіх доступних операцій рефакторингу для вибраного елемента.
	2. Статистичні аналізатори коду з підтримкою рефакторингу
	Статистичні аналізатори коду – це інструменти, які автоматично перевіряють якість коду, визначають проблемні ділянки та пропонують шляхи їх покращення. Вони допомагають знизити технічний борг і забезпечити високу якість коду ще на ранніх етапах розробки. Інтеграція цих аналізаторів із процесом рефакторингу дозволяє розробникам легко виявляти та усувати недоліки. Розглянемо найбільш популярні статистичні аналізатори.
	Codacy є багатофункціональним інструментом для перевірки якості коду, який підтримує понад 40 мов програмування. Він дозволяє ідентифікувати дублювання, оцінювати складність методів і класів, а також виявляти потенційні помилки. Codacy автоматично аналізує pull-реквести в GitHub, GitLab або Bitbucket, забезпечуючи безперервний моніторинг якості коду. Завдяки інтеграції з Git-платформами цей аналізатор є ідеальним вибором для командної роботи та забезпечення високої якості коду на всіх етапах розробки.
	ESLint спеціалізується на JavaScript і TypeScript, пропонуючи широкий набір інструментів для підтримки стандартів коду. Він допомагає виявити порушення стилістичних і функціональних правил, а також автоматично виправляє більшість помилок. ESLint підтримує стандартизацію стилю коду, видаляє застарілі конструкції та допомагає оптимізувати залежності, що підвищує продуктивність і полегшує командну роботу.
	SonarQube – це потужний інструмент для аналізу якості коду, який підтримує понад 25 мов програмування. Він дозволяє розробникам виявляти дублювання коду, складні умови, проблеми з безпекою та технічний борг. SonarQube інтегрується з CI/CD-процесами, такими як Jenkins, GitHub Actions і Azure DevOps, автоматично перевіряючи якість коду на кожному етапі розробки. Інструмент пропонує практичні рекомендації для рефакторингу, допомагаючи спростити логіку, зменшити складність і усунути дублювання. Завдяки SonarQube команди можуть забезпечити стабільність, читабельність і надійність коду, що робить його незамінним у великих і довготривалих проєктах.

ВИСНОВОК

     Рефакторинг є важливою складовою розробки програмного забезпечення, яка забезпечує високу якість коду протягом усього життєвого циклу проєкту. У сучасних умовах швидких змін вимог та розвитку технологій чистий, структурований і модульний код є ключем до успішного програмного забезпечення. Рефакторинг допомагає зменшити технічний борг, покращити читабельність, спростити тестування та забезпечити довготривалу підтримку.
     Методи рефакторингу доцільно застосовувати, коли код стає важким для розуміння, тестування або розширення. Це особливо важливо при наявності складних умовних конструкцій, дублювань логіки чи неконтрольованого доступу до даних. Процес рефакторингу має бути поступовим, без зміни функціональності програми, із залученням автоматизованого тестування для перевірки змін. Його також слід інтегрувати в регулярний процес розробки, щоб уникнути накопичення технічного боргу.
     Застосування таких методів, як Decompose Conditional, Separate Query from Modifier та Encapsulate Collection, демонструє, як структурований підхід дозволяє зробити код більш читабельним, модульним і адаптивним. Використання інструментів, таких як інтегровані засоби рефакторингу в IDE та статистичні аналізатори коду, значно спрощує цей процес, підвищуючи ефективність і якість виконаних змін.
     Рекомендації для виконання рефакторингу:
1. Плануйте зміни: перед початком рефакторингу визначте конкретні проблеми в коді та методи, які будуть використані для їх усунення.
2. Дотримуйтесь принципу "одна зміна за раз": вносьте зміни поступово, щоб легше було відстежувати та тестувати їхній вплив.
3. Використовуйте автоматизоване тестування: переконайтеся, що кожна зміна проходить через набір тестів, які гарантують збереження функціональності.
4. Зберігайте функціональність програми: рефакторинг не повинен змінювати поведінку програми, лише її внутрішню структуру.
5. Уникайте великих переробок: виконуйте рефакторинг поступово, щоб уникнути масштабних змін, які можуть викликати збої.
6. Інтегруйте рефакторинг у регулярний процес розробки: виділяйте час на рефакторинг у рамках кожного спринту чи задачі, щоб уникнути накопичення технічного боргу.
7. Використовуйте інструменти для аналізу коду: інтегруйте статистичні аналізатори коду та засоби рефакторингу IDE для оптимізації процесу.
8. Залучайте команду до рев’ю змін: проводьте огляди коду після рефакторингу, щоб переконатися в його якості та отримати зворотний зв’язок.
9. 

ДОДАТОК А
Список використаних джеред

     1. Martin Fowler. Refactoring. Improving the Design of Existing Code– AddisonWesley Professional, 1999. – 464 p. — Дата звернення: 23 грудня 2024 р.
     

ДОДАТОК Б
Відео на YouTube

https://youtu.be/NI2yeDrBS9c


ДОДАТОК В
Презентація









 































2


